---
title: "Healthcare Claims Sequences Analysis"
author: "Mustafa Ascha"
date: "September 5, 2016"
output: md_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Purpose

[There are](http://michael.hahsler.net/research/arules_RUG_2015/talk/arules_RUG2015.pdf) [a lot](http://www.rdatamining.com/examples/association-rules) of [great resources](http://statistical-research.com/association-rule-learning-and-the-apriori-algorithm/) for [performing market-basket (association) analysis](http://www.salemmarafi.com/code/market-basket-analysis-with-r/). 

There are, however, fewer resources on mining sequences data. This document will review how to run the CSPADE sequences analysis algorithm starting from a set of billing claims. As you might expect, cleaning the data is the hard part. For anyone who was in my position and had billing claims, this might help save some time. 

## Software

There are a few packages for mining sequences associations in R. I'll be using [arulesSequences](https://cran.r-project.org/web/packages/arulesSequences/index.html) for this post, but I would like to point out one alternative, [TraMineR](http://traminer.unige.ch/). 

The TraMineR website has a lot of resources, though there seem to be fewer for aruelsSequences. The best source for learning arulesSequences, at the moment, appears to be [this Data Mining Algorithms in R Wikibook](https://en.wikibooks.org/wiki/Data_Mining_Algorithms_In_R/Sequence_Mining/SPADE). The previously-linked tutorial uses data provided by the arulesSequences package, though, and I know that I had trouble figuring out how to make things work using my own data. 

We'll be using the tidyverse packages to fit data into its correct format. Here are the libraries you'll need: 


```{r libraries, message = FALSE}

library(pander)
library(lubridate)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)

```



## Data

Alright, so first let's simulate some data. I'll be working under the assumption that you have a list of one diagnosis per patient, though there may be several listings for the same visit. 

Because we are working with healthcare data, it is important to note that we will consider each patient to be an "event". This becomes useful as we construct the data. 

Our goal will be to move from the format of:

```{r sim_from, echo = FALSE}

set.seed(1000)

sim_from <- 
  data.frame(patient_ID = 1:2, 
           patient_diagnosis = c("Heart", "Lung", "Lung", "Liver"), 
           date_visit = seq(from = as.Date("1910/1/1"), to = as.Date("1910/1/30"), length.out = 4))

pander(sim_from)

```


to the format: 

```{r sim_to, echo = FALSE}

data.frame(items = c("Heart", "Lung", "Liver", "Brain"), 
           sequenceID = c(1, 1, 2, 2),
           eventID = c(1, 2, 1, 2), 
           size = rep(1, 4)) %>% 
pander()

```

Note that, because there is more than one diagnosis per patient-visit, we will have a size greater than one. 

If you want to see the example provided by `arulesSequences`, you can do the following: 

```{r zaki_example, message = FALSE, echo = FALSE}

library(arulesSequences)

data(zaki)

pander(as(zaki, "data.frame"))

```

```{r clean_zaki, echo = FALSE}

rm(zaki)

detach(package:arulesSequences)

detach(package:arules)

detach(package:Matrix)

```

To simulate data, I'll be using a list of fake diseases that correlate to each `patient_diagnosis` as follows:

```{r diagnosis_codes, echo = FALSE}

diagnosis_codes <- 
  data.frame(patient_diagnosis = 1:10, 
             disease = c("Heart", "Lung", "Kidney", "Liver", "Gall Bladder",
                         "Foot", "Mouth", "Colon", "Shoulder", "Hair"))

pander(diagnosis_codes)

```


Here's how we'll simulate the data: 

```{r sim_from_construction}

sim_from <- 
  data.frame(patient_ID = 
               rep_len(1:5, 100), 
           patient_diagnosis = 
               round(runif(n = 100, min = 1, max = 10)), 
           date_visit = 
               rep_len(paste("1990/1/", 1:30, sep = ""), length.out = 100))

```

The reason why I insist on using diagnosis codes is because healthcare billing claims are often coded according to the [International Classfication of Disease](https://en.wikipedia.org/wiki/International_Statistical_Classification_of_Diseases_and_Related_Health_Problems), [Healthcare Common Procedure Coding System](https://en.wikipedia.org/wiki/Healthcare_Common_Procedure_Coding_System), or [Current Procedural Terminology](https://en.wikipedia.org/wiki/Current_Procedural_Terminology). You can find a list of [ICD codes to diagnoses](https://www.cms.gov/Medicare/Coding/ICD9ProviderDiagnosticCodes/codes.html) or [HCPCS codes to procedures](https://www.cms.gov/Medicare/Coding/HCPCSReleaseCodeSets/index.html) at the Centers for Medicare and Medicaid Services website if you're interested. I've found that CPT codes are harder to obtain, though [feel free to email me and let me know if they're easily available](mustafa.ascha@gmail.com). 

## Cleaning the data so it fits

There are a couple of issues with the initial format: 

* We've got dates, but we need sequences
* We need the diagnosis names instead of their codes
* We need all of the items for each transaction listed in one row, instead of one row for each transaction-diagnosis



### Fixing the date

Let's start with lubridating the dates for easier handling: 

```{r lubridating}

sim_from$date_visit <- 
  parse_date_time(sim_from$date_visit, orders = "ymd")

```

And then we'll turn them into rankings for each patient-visit using the `dplyr` function `dense_rank` to rank.There may be multiple diagnoses per patient-visit, but this isn't an issue because the `dense_rank` function handles ties by assigning the same value to each tied observation.

```{r making_sequences}

sim_from <- 
  sim_from %>% 
  group_by(patient_ID) %>% 
  mutate(sequenceID = dense_rank(date_visit)) %>%
  data.frame()

```

And let's see how that looks: 

```{r view_making_sequences}

pander(head(sim_from))

```

We don't need the date anymore because we'll just be looking at sequences, so let's get rid of that: 

```{r remove_date}

sim_from$date_visit <- NULL

```


Given the simulated data, we can expect three or four diagnoses per patient-visit. Here's a summary of the number of diagnoses for patient number 1: 

```{r view_counts}

sim_from %>%
  group_by(patient_ID, sequenceID) %>% 
  summarize(diagnoses_size = n()) %>% 
  head %>% 
  pander

```



### Translating diagnosis codes

This part isn't too hard, it's just a `left_join`. To learn more about two-table verbs, [check out this very useful tutorial](http://stat545.com/bit001_dplyr-cheatsheet.html). I've referred to that website more times than I can count, and it makes me think I should understand SQL better than I do. 

Anyway, here's the code and a sample of its output: 

```{r left_join, message = TRUE}

sim_from <- 
  left_join(sim_from, diagnosis_codes)

```


You'll notice that `dplyr` says the tables were joined by "patient_diagnosis". That's the only variable common between the two tables, so `dplyr` picked it as the ID variable to use for joining. 

Here's what the joined table looks like: 

```{r view_left_join}

pander(head(sim_from))

```

When doing sequences analysis, it's a lot easier to interpret the words "heart" and "lung" than it is to refer numbers back to diseases. So, we'll remove the coded diagnosis and keep the disease name. 

```{r remove_codes}

sim_from$patient_diagnosis <- NULL

```

### Making a basket size variable

Given the CSPADE program's requirements, we'll need to make a variable for the number of diagnoses at that visit. `dplyr` makes this task really easy!

```{r counts}

sim_from <- 
 sim_from %>% 
  group_by(patient_ID, sequenceID) %>% 
  mutate(basket_size = n())

```

Let's see what we've got, at this point: 

```{r view_counts_sizes}

pander(head(sim_from))

```



### Splitting by patient-visit

I already mentioned that the CSPADE algorithm used by `arulesSequences` is specific about the format of the data required, but this is probably the most CSPADE-specific requirement. For the data format used in this tutorial, we'll have to make a new variable listing each disease that was diagnosed at a patient's visit.

In keeping with `arulesSequences` standards, we'll refer to the diagnoses as "items". 

```{r splitting}


sim_from$disease <- as.character(sim_from$disease)

sim_split <- 
  sim_from %>% 
  group_by(patient_ID, basket_size, sequenceID) %>% 
  nest() %>% 
  mutate(items = map_chr(data, paste0, ","))
  
```

Here's a look at what we've got so far: 

```{r split_view}

pander(head(sim_split))

```

The data appears to be in the right form at this point because `tidyr` data shows up that way. However, we'll need to do a little bit of string formatting before we've reached the right form for CSPADE. 

I'll remove the `data`, now that we've got a list of each patient-visit. 

```{r rm_data}

sim_split$data <- NULL

```

And then also fix the strings so that they look like "zaki".

```{r string_formatting}

sim_split$items <- 
  str_replace_all(sim_split$items, 
                  pattern = "^c\\(|\\)", 
                  replacement = "") %>% 
  str_replace_all(pattern = '"', replacement = "") %>% 
  as.character

```

I added the `as.character` because `stringr` returns more complex data structures. 

Besides the curly braces that wrap the items in "zaki", this looks complete: 

```{r view_str_formatting}

pander(head(sim_split))

```

The hardest part is now over.

## Running the algorithm

Alright, so let's load the `arulesSequences` library: 

```{r load_arules, message = FALSE}

library(arulesSequences)

```

`read_baskets` only accepts data that is written to disk, so we'll have to do that: 

```{r write_data}

write.table(sim_split, "transactions.csv", 
            row.names = FALSE, 
            col.names = FALSE,
            sep = ' ',
            quote = FALSE)

```

And now we can get the data in transactions form:

```{r read_baskets}

sim_tx <- 
  read_baskets("transactions.csv", info = c("eventID", "size", "sequenceID"))

```

Let's see how that looks as a `data.frame`: 

```{r see_sim_tx}

pander(head(as(sim_tx, "data.frame")))

```

Nice! 

Knowing that the data was randomly generated, we shouldn't expect to find anything very interesting. Still, let's run the algorithm: 


```{r run}

sim_cspade <- 
  cspade(sim_tx, 
         parameter = list(support = 0.1, maxlen = 3, mingap = 2), 
         control = list(verbose = TRUE, summary = TRUE, bfstype = TRUE))

```

### Interpreting results

[I'll point one of the `arules` package author's tutorials](http://michael.hahsler.net/research/arules_RUG_2015/demo/) before writing anything myself, but I will start by saying it's pretty easy to explore the analysis. 

First, let's see what R tells us if we try to directly look at the object: 

```{r view_sim}

sim_cspade

```

Alright, that's helpful information. We have 72 sequences. 

The `inspect` function is really the workhorse that we'll use, here. `inspect` allows you to subset, which is really useful if you know what sorts of things you'd like to learn about the data. 

Here's a peek at what `inspect` says when we give it the simulated data: 

```{r inspect_sim}

inspect(sim_cspade[1:10])

```

Well, that's not very interesting. It's saying that `1/30` people had each of those sequences. That's one person...out of the entire cohort of 30. 

## Closing thoughts

It's not too surprising that getting data to fit the analysis was the hardest part of this exercise. Still, I am surprised. 

These data aren't too interesting. In my next post, I hope to inject a little bias into the data to see what happens. Maybe something like making every one of the last sequences "Heart" or "Foot", to see what the algorithm has to say. 

I'll also note that there is a whole lot more to do with the `arulesSequences` and `arules` packages. There are cool visualizations, for example. 

Until next time, happy hunting! 










